import {
    score as fzyScore,
    hasMatch
} from 'fzy.js';
import {
    crc32
} from '@allex/crc32';
export class StaticItemsPage {
    constructor(title, scopeId, items) {
        this.providers = [];
        this.scopeType = 'static_items_page';
        this.title = title;
        this.scopeId = scopeId;
        this.providers = [new StaticItemsProvider(items)];
    }
}
export class StaticItemsProvider {
    constructor(items) {
        this.hasCommands = true;
        this.debounce = 0;
        const itemsCount = items.length;
        this.items = items.map((item, index) => {
            item.priority = itemsCount - index;
            return item;
        });
    }
    async fetch(query) {
        const items = this.fuzzyFilter(this.items, query);
        return {
            results: items
        };
    }
    enabledFor() {
        return true;
    }
    clearCache() {}
    fuzzyFilter(items, query, minScore = 0) {
        if (query.isBlank()) {
            return items;
        }
        const matchingItems = [];
        for (const item of items) {
            const score = item.calculateScore(query.text);
            if (score > minScore) {
                matchingItems.push(item);
            }
        }
        return matchingItems;
    }
}
export class Item {
    constructor(data) {
        this.score = 0;
        this.position = '';
        this.title = data.title;
        this.priority = data.priority;
        this.group = data.group;
        this.subtitle = data.subtitle;
        this.matchFields = data.matchFields;
        this.typeahead = data.typeahead;
        this.hint = data.hint;
        this.icon = data.icon;
    }
    get matchingFields() {
        if (this.matchFields) {
            return this.matchFields;
        } else {
            return [this.title];
        }
    }
    get key() {
        return `${this.title}-${this.group}-${this.subtitle}-${this.matchFields?.join('-')}`;
    }
    get id() {
        if (!this._id) {
            this._id = crc32(this.key).toString();
        }
        return this._id;
    }
    calculateScore(queryText) {
        const scores = this.matchingFields.map(field => this.calculateScoreForField({
            field,
            queryText
        }));
        return Math.max(...scores);
    }
    calculateScoreForField({
        field,
        queryText
    }) {
        if (hasMatch(queryText, field)) {
            return fzyScore(queryText, field);
        } else {
            return -Infinity;
        }
    }
}